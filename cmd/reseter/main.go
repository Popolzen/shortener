package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

type structInfo struct {
	name   string
	fields []fieldInfo
}

type fieldInfo struct {
	name    string
	typeStr string
	isPtr   bool
	isSlice bool
	isMap   bool
}

func main() {
	pkgs := make(map[string][]structInfo)

	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") {
			return err
		}
		if strings.HasSuffix(path, ".gen.go") || strings.Contains(path, "cmd/reset") {
			return nil
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		pkgPath := filepath.Dir(path)
		for _, decl := range node.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}
				if structType.Fields == nil {
					continue
				}

				if genDecl.Doc == nil {
					continue
				}
				hasGenerate := false
				for _, comment := range genDecl.Doc.List {
					if strings.Contains(comment.Text, "generate:reset") {
						hasGenerate = true
						break
					}
				}
				if !hasGenerate {
					continue
				}

				si := structInfo{name: typeSpec.Name.Name}
				for _, field := range structType.Fields.List {
					for _, name := range field.Names {
						fi := fieldInfo{name: name.Name}
						fi.typeStr, fi.isPtr, fi.isSlice, fi.isMap = parseType(field.Type)
						si.fields = append(si.fields, fi)
					}
				}
				pkgs[pkgPath] = append(pkgs[pkgPath], si)
			}
		}
		return nil
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	for pkgPath, structs := range pkgs {
		if err := generateFile(pkgPath, structs); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating %s: %v\n", pkgPath, err)
		}
	}
}

func parseType(expr ast.Expr) (string, bool, bool, bool) {
	switch t := expr.(type) {
	case *ast.StarExpr:
		typeStr, _, isSlice, isMap := parseType(t.X)
		return typeStr, true, isSlice, isMap
	case *ast.ArrayType:
		typeStr, isPtr, _, isMap := parseType(t.Elt)
		return typeStr, isPtr, true, isMap
	case *ast.MapType:
		return "", false, false, true
	case *ast.Ident:
		return t.Name, false, false, false
	case *ast.SelectorExpr:
		if xIdent, ok := t.X.(*ast.Ident); ok {
			return fmt.Sprintf("%s.%s", xIdent.Name, t.Sel.Name), false, false, false
		}
		return "", false, false, false
	}
	return "", false, false, false
}

func generateFile(pkgPath string, structs []structInfo) error {
	dir := filepath.Base(pkgPath)
	if dir == "." {
		dir = "main"
	}

	var sb strings.Builder
	sb.WriteString("// Code generated by reset generator. DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", dir))

	for _, s := range structs {
		sb.WriteString(fmt.Sprintf("func (r *%s) Reset() {\n", s.name))
		sb.WriteString("\tif r == nil {\n\t\treturn\n\t}\n\n")

		for _, f := range s.fields {
			switch {
			case f.isSlice:
				sb.WriteString(fmt.Sprintf("\tr.%s = r.%s[:0]\n", f.name, f.name))
			case f.isMap:
				sb.WriteString(fmt.Sprintf("\tclear(r.%s)\n", f.name))
			case f.isPtr:
				sb.WriteString(fmt.Sprintf("\tif r.%s != nil {\n", f.name))
				if isPrimitive(f.typeStr) {
					sb.WriteString(fmt.Sprintf("\t\t*r.%s = %s\n", f.name, zeroValue(f.typeStr)))
				} else {
					sb.WriteString(fmt.Sprintf("\t\tif resetter, ok := r.%s.(interface{ Reset() }); ok {\n", f.name))
					sb.WriteString("\t\t\tresetter.Reset()\n\t\t}\n")
				}
				sb.WriteString("\t}\n")
			default:
				sb.WriteString(fmt.Sprintf("\tr.%s = %s\n", f.name, zeroValue(f.typeStr)))
			}
		}
		sb.WriteString("}\n\n")
	}

	outPath := filepath.Join(pkgPath, "reset.gen.go")
	return os.WriteFile(outPath, []byte(sb.String()), 0644)
}

func isPrimitive(t string) bool {
	primitives := []string{"int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "string", "bool", "byte", "rune"}
	for _, p := range primitives {
		if t == p {
			return true
		}
	}
	return false
}

func zeroValue(t string) string {
	switch t {
	case "string":
		return `""`
	case "bool":
		return "false"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "byte", "rune":
		return "0"
	default:
		return fmt.Sprintf("%s{}", t)
	}
}
